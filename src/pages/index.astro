---
import Layout from '../layouts/Layout.astro';
import { trips } from '../data/trips';
import { Image } from 'astro:assets';

// Load all images eagerly
const dayImages = import.meta.glob('../assets/images/day/*.{jpg,jpeg,png,webp}', { eager: true });
const nightImages = import.meta.glob('../assets/images/night/*.{jpg,jpeg,png,webp}', { eager: true });

// Helper to process images
const processImages = (imagesRecord: Record<string, unknown>, isNightFolder: boolean) => {
  return Object.entries(imagesRecord).map(([path, module]) => {
    // Extract filename from path (e.g., "../assets/images/day/photo.jpg" -> "photo.jpg")
    const filename = path.split('/').pop();
    
    // Find metadata
    const meta = trips.find(t => t.filename === filename);
    
    // Get image source (module.default for default export in Astro/Vite)
    // Cast to any because the type isn't strictly defined in this context without extra setup
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const imageSrc = (module as any).default;

    return {
      id: meta?.id || filename, // Use filename as fallback ID
      title: meta?.title || 'Untitled',
      location: meta?.location || 'Unknown Location',
      image: imageSrc,
      fullRes: imageSrc.src, 
      date: meta?.date || '',
      isNight: isNightFolder, // Enforce folder source for logic
      size: meta?.size || 'normal'
    };
  });
};

const dayTrips = processImages(dayImages, false);
const nightTrips = processImages(nightImages, true);

// Combine and sort
const allTrips = [...dayTrips, ...nightTrips].sort((a, b) => {
    // If both have numeric IDs from data, sort by ID to maintain original curated order
    if (typeof a.id === 'number' && typeof b.id === 'number') {
        return a.id - b.id;
    }
    // If only one has ID, prioritize it? Or just keep them mixed.
    if (typeof a.id === 'number') return -1;
    if (typeof b.id === 'number') return 1;
    return 0;
});

const getSizeClass = (size: string) => {
  switch (size) {
    case 'wide': return 'md:col-span-2';
    case 'tall': return 'md:row-span-2';
    case 'big': return 'md:col-span-2 md:row-span-2';
    default: return '';
  }
};
---

<Layout title="Home">
  <div class="page-container">
    <div class="section-header animate-fade-in-down">
      <h1 class="page-title">Hej Emma</h1>
      <p class="page-subtitle">
        Random ahhh pictures fra din flickr.
      </p>
    </div>

    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8 grid-flow-dense" id="trips-grid">
      {allTrips.map((trip, _) => (
        <div 
          class={`trip-card trip-card-base group opacity-0 translate-y-8 ${getSizeClass(trip.size)}`}
          data-full-res={trip.image.src}
          data-title={trip.title}
          data-location={trip.location}
          data-is-night={trip.isNight.toString()}
        >
          <div class="w-full h-full bg-gray-200">
             <Image 
              src={trip.image} 
              alt={trip.title}
              width={600} 
              height={384}
              class="object-cover w-full h-full min-h-96 group-hover:scale-105 transition-transform duration-700 ease-in-out"
              loading={"eager"}
            />
          </div>
          <div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-6 text-white opacity-100 sm:opacity-0 sm:group-hover:opacity-100 transition-opacity duration-300 pointer-events-none">
            <h3 class="text-xl font-bold">{trip.title}</h3>
            <p class="text-sm font-medium opacity-90">{trip.location} &bull; {trip.date}</p>
          </div>
        </div>
      ))}
    </div>
  </div>

  <!-- Lightbox Modal -->
  <div id="lightbox" class="fixed inset-0 z-[100] hidden bg-black/90 backdrop-blur-sm transition-opacity duration-300 opacity-0" aria-hidden="true">
    <!-- Close button -->
    <button id="lightbox-close" class="absolute top-4 right-4 text-white hover:text-gray-300 focus:outline-none z-50 p-2">
      <span class="sr-only">Close</span>
      <svg class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
      </svg>
    </button>

    <!-- Navigation Buttons -->
    <button id="lightbox-prev" class="absolute left-4 top-1/2 transform -translate-y-1/2 text-white hover:text-gray-300 focus:outline-none z-50 p-4 hidden sm:block">
      <span class="sr-only">Previous</span>
      <svg class="h-10 w-10" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
      </svg>
    </button>
    
    <button id="lightbox-next" class="absolute right-4 top-1/2 transform -translate-y-1/2 text-white hover:text-gray-300 focus:outline-none z-50 p-4 hidden sm:block">
      <span class="sr-only">Next</span>
      <svg class="h-10 w-10" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
      </svg>
    </button>

    <!-- Content -->
    <div class="flex items-center justify-center h-full w-full p-4">
      <img id="lightbox-img" src="" alt="" class="max-h-[85vh] max-w-[90vw] object-contain shadow-2xl rounded-sm transform scale-95 transition-transform duration-300 select-none" />
      
      <!-- Gradient Overlay for better text readability -->
      <div class="absolute bottom-0 left-0 right-0 h-48 bg-gradient-to-t from-black/90 via-black/50 to-transparent pointer-events-none"></div>

      <div class="absolute bottom-8 left-0 right-0 text-center text-white pointer-events-none px-4">
          <h3 id="lightbox-title" class="text-2xl font-serif font-bold tracking-wide drop-shadow-lg">&nbsp;</h3>
          <p id="lightbox-location" class="text-lg opacity-90 mt-2 drop-shadow-md font-medium"></p>
      </div>
    </div>
  </div>
</Layout>

<script>
  // Function to setup all interactivity
  function setupInteractivity() {
    // --- Scroll Animations ---
    const observerOptions = {
      root: null,
      rootMargin: '0px',
      threshold: 0.1
    };

    const cards = document.querySelectorAll('.trip-card');
    const cardsArray = Array.from(cards);

    const observer = new IntersectionObserver((entries) => {
      // Get all intersecting entries
      const intersecting = entries.filter(e => e.isIntersecting);
      
      // Sort them by their position in the DOM to ensure top-to-bottom animation
      intersecting.sort((a, b) => {
          return cardsArray.indexOf(a.target) - cardsArray.indexOf(b.target);
      });

      // Animate them one after another
      intersecting.forEach((entry, index) => {
        const target = entry.target as HTMLElement;
        // Stagger the delay based on the index WITHIN this batch
        target.style.transitionDelay = `${index * 150}ms`; 
        target.classList.remove('opacity-0', 'translate-y-8');
        observer.unobserve(target);
      });
    }, observerOptions);

    // Store original cards list for lightbox navigation context
    let visibleCards: Element[] = Array.from(cards);
    
    cards.forEach((card) => {
      // Remove any pre-existing delay so we control it dynamically
      (card as HTMLElement).style.transitionDelay = '0ms';
      observer.observe(card);
    });

    // --- Filter Logic ---
    
    const filterCards = (theme: string) => {
        const isNightMode = theme === 'dark';
        
        // Reset animation delays for smoother re-appearance
        cards.forEach((card) => {
             (card as HTMLElement).style.transitionDelay = '0ms';
        });

        visibleCards = []; // Reset visible list for lightbox

        cards.forEach((card) => {
            const isNight = card.getAttribute('data-is-night') === 'true';
            
            if (isNightMode) {
                // Night mode: Show ONLY night images
                if (isNight) {
                    card.classList.remove('hidden');
                    visibleCards.push(card);
                } else {
                    card.classList.add('hidden');
                }
            } else {
                // Day mode: Show ALL images
                card.classList.remove('hidden');
                visibleCards.push(card);
            }
        });
    };

    // Listen for global theme changes
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    window.addEventListener('theme-change', (e: any) => {
        filterCards(e.detail.theme);
    });

    // Initial filter check
    const currentTheme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
    filterCards(currentTheme);

    // --- Lightbox ---
    const lightbox = document.getElementById('lightbox');
    const lightboxImg = document.getElementById('lightbox-img') as HTMLImageElement;
    const lightboxTitle = document.getElementById('lightbox-title');
    const lightboxLocation = document.getElementById('lightbox-location');
    const closeBtn = document.getElementById('lightbox-close');
    const prevBtn = document.getElementById('lightbox-prev');
    const nextBtn = document.getElementById('lightbox-next');

    let currentVisibleIndex = 0;

    if (!lightbox || !lightboxImg || !closeBtn || !prevBtn || !nextBtn) return;

    const preloadImage = (url: string) => {
        const img = new Image();
        img.src = url;
    };

    const updateLightboxImage = (index: number) => {
        const card = visibleCards[index];
        if (!card) return;

        const imgUrl = card.getAttribute('data-full-res');
        const title = card.getAttribute('data-title') || '';
        const location = card.getAttribute('data-location') || '';

        lightboxImg.style.opacity = '0.5';
        
        setTimeout(() => {
            if (imgUrl) lightboxImg.src = imgUrl;
            if (lightboxTitle) lightboxTitle.textContent = title;
            if (lightboxLocation) lightboxLocation.textContent = location;
            lightboxImg.style.opacity = '1';
        }, 150);

        currentVisibleIndex = index;

        // Preload based on VISIBLE cards
        const nextIndex = (index + 1) % visibleCards.length;
        const prevIndex = (index - 1 + visibleCards.length) % visibleCards.length;
        
        const nextUrl = visibleCards[nextIndex]?.getAttribute('data-full-res');
        const prevUrl = visibleCards[prevIndex]?.getAttribute('data-full-res');

        if (nextUrl) preloadImage(nextUrl);
        if (prevUrl) preloadImage(prevUrl);
    };

    const openLightbox = (card: Element) => {
      // Find index of this card in the currently visible list
      const index = visibleCards.indexOf(card);
      if (index === -1) return;

      updateLightboxImage(index);
      
      lightbox.classList.remove('hidden');
      requestAnimationFrame(() => {
        lightbox.classList.remove('opacity-0');
        lightboxImg.classList.remove('scale-95');
        lightboxImg.classList.add('scale-100');
      });
      document.body.style.overflow = 'hidden';
    };

    const closeLightbox = () => {
      lightbox.classList.add('opacity-0');
      lightboxImg.classList.remove('scale-100');
      lightboxImg.classList.add('scale-95');
      
      setTimeout(() => {
        lightbox.classList.add('hidden');
        lightboxImg.src = '';
        document.body.style.overflow = '';
      }, 300);
    };

    const showNext = (e?: Event) => {
        e?.stopPropagation();
        let newIndex = currentVisibleIndex + 1;
        if (newIndex >= visibleCards.length) newIndex = 0;
        updateLightboxImage(newIndex);
    };

    const showPrev = (e?: Event) => {
        e?.stopPropagation();
        let newIndex = currentVisibleIndex - 1;
        if (newIndex < 0) newIndex = visibleCards.length - 1;
        updateLightboxImage(newIndex);
    };

    // Attach click events to cards
    cards.forEach((card) => {
      card.addEventListener('click', () => {
          openLightbox(card);
      });
    });

    // Close events
    closeBtn.addEventListener('click', closeLightbox);
    
    // Navigation events
    nextBtn.addEventListener('click', showNext);
    prevBtn.addEventListener('click', showPrev);

    // Close on background click
    lightbox.addEventListener('click', (e) => {
        const target = e.target as HTMLElement;
        if (target === lightbox || target.closest('.flex')) {
             if (target !== lightboxImg && !target.closest('button')) {
                 closeLightbox();
             }
        }
    });

    // Keyboard events
    document.addEventListener('keydown', (e) => {
      if (lightbox.classList.contains('hidden')) return;

      if (e.key === 'Escape') {
        closeLightbox();
      } else if (e.key === 'ArrowRight') {
        showNext();
      } else if (e.key === 'ArrowLeft') {
        showPrev();
      }
    });

    // Touch events for swipe navigation
    let touchStartX = 0;
    let touchEndX = 0;

    lightbox.addEventListener('touchstart', (e) => {
        touchStartX = e.changedTouches[0].screenX;
    }, { passive: true });

    lightbox.addEventListener('touchend', (e) => {
        touchEndX = e.changedTouches[0].screenX;
        handleSwipe();
    }, { passive: true });

    function handleSwipe() {
        if (touchEndX < touchStartX - 50) {
            // Swipe Left -> Next
            showNext();
        }
        if (touchEndX > touchStartX + 50) {
            // Swipe Right -> Prev
            showPrev();
        }
    }
  }

  // Run on initial load
  setupInteractivity();

  // Run on view transition navigation
  document.addEventListener('astro:page-load', setupInteractivity);
</script>